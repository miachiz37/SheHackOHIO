import { create } from "zustand";


const defaultPrefs = {
  pork: 3,
  nuts: 3,
  dairy: 3,
  vegetables: 3,
  fruits: 3,
};

export const useAppStore = create((set, get) => ({
  // Profile + preferences
  profile: {
    restrictions: [],
    macros: { protein: 120, carb: 170, fat: 55 },
    otherPreferences: "",
    goal: "fat-loss",
    prefs: { ...defaultPrefs }, // 0–5 sliders
  },

  // Pantry & suggestions
  pantry: [], // { name, type: 'meat'|'produce'|'other', freshness: 'today'|'soon'|'ok' }
  plan: null,
  recipes: [], //harker added
  loading: false,
/*
 FIXME: When we switch to real backend or Danni's AI, replace the mock pool below with:
   const pool = get().recipes;

   This will use the real recipe data fetched from the backend (via fetchRecipes) or generated by AI.
   Make sure fetchRecipes is uncommented and called (e.g., in Plan.jsx with useEffect).
   Also update pantryMatches and expiryBonus to use r.extendedIngredients instead of r.uses:
     r.extendedIngredients?.reduce?.((s, u) => s + (have.has(u.name?.toLowerCase()) ? 1 : 0), 0) ?? 0

   This keeps the scoring logic intact while adapting to real data structure.
   The rest of suggestRecipes can stay the same — just swap the source and ingredient access.
  
   fetchRecipes: async () => {
    try{
      const res = await fetch("http://localhost:8080/api/search", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ limit: 6 })
      });
    const data = await res.json();
    set({ recipes: data.recipes || [] });
  } catch (err) {
    console.error("Failed to fetch recipes:", err);
    }
  },
  */
  // Mutators
  setProfile: (patch) => set((s) => ({ profile: { ...s.profile, ...patch } })),
  setPref: (key, value) =>
    set((s) => ({ profile: { ...s.profile, prefs: { ...s.profile.prefs, [key]: value } } })),
  addIngredient: (item) => set((s) => ({ pantry: [...s.pantry, item] })),
  removeIngredient: (name) =>
    set((s) => ({ pantry: s.pantry.filter((i) => i.name !== name) })),
  setLoading: (loading) => set({ loading }),
  setPlan: (plan) => set({ plan }),

  // Very simple suggestion heuristic (mock)
  suggestRecipes: () => {
    /* FIXMEwhen we wanna use Danni's
    const pool = get().recipes; */
    
    const { prefs } = get().profile;
    const pantry = get().pantry;
    // tiny mock recipe pool
    const pool = [
      { id: 1, title: "Pork Stir Fry", tags: ["pork", "vegetables"], uses: ["pork", "broccoli"] },
      { id: 2, title: "Nutty Berry Yogurt", tags: ["nuts", "dairy", "fruits"], uses: ["yogurt", "berries", "almonds"] },
      { id: 3, title: "Veggie Bowl", tags: ["vegetables"], uses: ["spinach", "rice", "beans"] },
      { id: 4, title: "Fruit Oat Parfait", tags: ["fruits", "dairy"], uses: ["oats", "berries", "yogurt"] },
      { id: 5, title: "Tofu Veggie Saute", tags: ["vegetables"], uses: ["tofu", "zucchini"] },
    ];
    // score by prefs (favor high-rated tags) + pantry matches + freshness
    const have = new Set(pantry.map((p) => p.name.toLowerCase()));
    const freshnessBoost = { today: 2, soon: 1, ok: 0 };
    const nearExpiry = new Set(
      pantry.filter((p) => p.freshness !== "ok").map((p) => p.name.toLowerCase())
    );

    return pool
      .map((r) => {
        const prefScore = r.tags.reduce((s, t) => s + (prefs[t] ?? 0), 0);
        const pantryMatches = r.uses.reduce((s, u) => s + (have.has(u) ? 1 : 0), 0);
        const expiryBonus = r.uses.reduce((s, u) => s + (nearExpiry.has(u) ? 1 : 0), 0);
        const score = prefScore + pantryMatches * 2 + expiryBonus * 1.5;
        return { ...r, score };
      })
      .sort((a, b) => b.score - a.score)
      .slice(0, 5);
  },
}));
